// RUN: %libomp-compile-and-run | FileCheck %s
// REQUIRES: ompt
// UNSUPPORTED: gcc

#include "callback.h"


#define DELAY 1000000
#define COUNT 10

// burn some CPU cycles
void burn_CPU(int count) {
  int j, k;
  volatile float x;
  int jmax;

  jmax = 7 * count;

  for (j = 0; j < jmax; j++) {
    x = 0;
    for (k = 0; k < DELAY; k++) {
      x = x + 1.0;
    }
  }
}

int main() {
#pragma omp parallel if(0)
  {
    burn_CPU(COUNT);
  }

  // Check if libomp supports the callbacks for this test.
  // CHECK-NOT: {{^}}0: Could not register callback 'ompt_callback_parallel_begin'
  // CHECK-NOT: {{^}}0: Could not register callback 'ompt_callback_parallel_end'


  // CHECK: {{^}}0: NULL_POINTER=[[NULL:.*$]]
  // CHECK: {{^}}[[MASTER_ID:[0-9]+]]: ompt_event_initial_task_begin

  // CHECK: {{^}}[[MASTER_ID]]: ompt_event_parallel_begin
  // CHECK-SAME: parallel_id=[[PARALLEL_ID_1:[0-9]+]]
  // CHECK-SAME: invoker=1

  // CHECK: {{^}}[[MASTER_ID]]: ompt_event_parallel_end
  // CHECK-SAME: parallel_id=[[PARALLEL_ID_1:[0-9]+]]
  // CHECK-SAME: invoker=1


  // Consider the callstack of the master thread while executing the burn_CPU
  // function when the code is generated by clang:
      // #0  burn_CPU (count=10)
      // #1  0x000000000040327a in .omp_outlined._debug__
      // #2  0x000000000040329d in .omp_outlined.
      // #3  0x000000000040323c in main ()

  // One can notice that the outlined function that corresponds to the implicit
  // tasks is invoked directly by the application, so the invoker should take
  // value of ompt_parallel_invoker_runtime==1


  return 0;
}
