// RUN: %libomp-compile-and-run | FileCheck %s
// REQUIRES: ompt
// UNSUPPORTED: gcc

#include "callback.h"


// introduced for better clarification.
void foo() {}

int main() {
#pragma omp parallel if(0)
  {
    foo();
  }

  // Check if libomp supports the callbacks for this test.
  // CHECK-NOT: {{^}}0: Could not register callback 'ompt_callback_parallel_begin'
  // CHECK-NOT: {{^}}0: Could not register callback 'ompt_callback_parallel_end'


  // CHECK: {{^}}0: NULL_POINTER=[[NULL:.*$]]
  // CHECK: {{^}}[[MASTER_ID:[0-9]+]]: ompt_event_initial_task_begin

  // CHECK: {{^}}[[MASTER_ID]]: ompt_event_parallel_begin
  // CHECK-SAME: parallel_id=[[PARALLEL_ID_1:[0-9]+]]
  // CHECK-SAME: invoker=1

  // CHECK: {{^}}[[MASTER_ID]]: ompt_event_parallel_end
  // CHECK-SAME: parallel_id=[[PARALLEL_ID_1:[0-9]+]]
  // CHECK-SAME: invoker=1


  // Consider the callstack of the master thread while executing the foo
  // function when the code is generated by clang:
      // #0  foo ()
      // #1  0x000000000040327a in .omp_outlined._debug__
      // #2  0x000000000040329d in .omp_outlined.
      // #3  0x000000000040323c in main ()

  // One can notice that the outlined function that corresponds to the implicit
  // tasks is invoked directly by the application, so the invoker should take
  // value of ompt_parallel_invoker_runtime==1


  return 0;
}
